---
title: '1795C - Tea Tasting'
tag: ['Codeforces', 'imos', '이진 탐색', '누적합']
link: 'https://codeforces.com/problemset/problem/1795/C'
description: ''
---

## 문제 설명

시음할 수 있는 차 n개의 용량이 배열 $a$로 주어지고, 시음자 n명의 한 시음당 마실수 있는 용량이 배열 $b$로 주어진다.

문제는 다음과 같은 단계를 반복한다.

1. $i$번째 사람은 $i$번째 차를 $min(a_i, b_i)$만큼 시음한다.
2. 시음을 마치면 $i$번째 사람은 $i-1$번째 차로 이동하여 $min(a_{i-1}, b_i)$만큼 또 마신다.

모두가 시음을 마칠 때 까지 반복했을 때, 시음자당 마신 차의 양을 출력해야한다.

## 풀이 방법

n값은 최대 $2 \cdot 1e5$ 이기 때문에 복잡도가 $O(n^2)$인 brute force 로는 통과할 수 없다.

이분 탐색으로 구간값을 구하고 imos로 결과값을 구하면 $O(n \cdot \log n)$ 시간에 해결할 수 있는 문제이다.

<br/>

$i$번째 차는 최대 $b_i + b_{i+1} + ... + b_{n}$ 만큼의 용량이 시음될 수 있다는 점을 찾을 수 있다.

$\sum_{k=i}^{n} b_k$ 값을 $O(1)$으로 찾기 위해 배열 $b$의 누적합을 구해둔다.

모든 시음자가 시음을 마쳤을 때 시음자 $i$가 먹은 용량은 $min(a_i, \sum_{k=i}^{n} b_k)$임을 알 수 있고, 이 값을 구해둔 누적합에서 lower bound로 검색하면 $i$번째 차를 마신 시음자의 구간을 알 수 있다.<br/>**(단, 누적합에서 값을 검색할 때는 범위에 포함되지 않는 padding값을 더해준 값으로 검색해야한다.)**

lower bound는 검색한 값 보다 크거나 같은 값의 인덱스를 반환하는데, 반환된 값의 인덱스와 검색한 값이 일치하다면 $[s, e]$로 판단하면 되고, 일치하지 않는다면 $[s, e)$과 부족한 $e$값으로 계산하면 된다.<br/>($[, ]$: 값 포함, $(, )$: 값 미포함)

마지막으로 imos를 구해야하는데 $[s, e] (s = e)$인 경우가 존재해 처리가 곤란하다. 이는 모든 구간의 값을 두 배 증가시켜주고 $e$값만 1씩 증가시켜 계산하면 된다.

imos를 이용해 구한 시음자의 시음 횟수와 배열 $b$ 값을 곱해주고, 부족한 시음량을 채워주면 정답을 구할 수 있다.