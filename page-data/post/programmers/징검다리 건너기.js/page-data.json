{"componentChunkName":"component---src-templates-post-tsx","path":"/post/programmers/징검다리 건너기.js","result":{"data":{"file":{"ext":".js","name":"징검다리 건너기","fields":{"content":"function solution(stones, k) {\n  var answer = 0;\n\n  const canGo = (c) => {\n    let tmp = k;\n\n    for (let i = 0; i < stones.length; i++) {\n      if (stones[i] - c < 0) {\n        if (!--tmp) {\n          return false;\n        }\n      } else {\n        tmp = k;\n      }\n    }\n\n    return true;\n  };\n\n  let l = 1;\n  let r = 2e8;\n\n  while (l < r) {\n    const m = Math.floor((l + r) / 2);\n\n    if (canGo(m)) {\n      answer = m;\n      l = m + 1;\n    } else {\n      r = m;\n    }\n  }\n\n  return answer;\n}\n","stampObject":{"modified":1685425281,"created":1685425281}}},"markdownRemark":{"html":"<blockquote>\n<p>효율성 테스트까지 통과할 수 있는 솔루션은 빠르게 찾았지만, 파라메트릭 서치의 결정조건 복잡도 계산과, 이분 탐색의 조건 설정을 제대로 하지 못한 탓에 시간이 걸렸다.</p>\n</blockquote>\n<h2>풀이 방법</h2>\n<p>징검다리의 수는 최대 20만이다. 만약 니니즈 친구들을 한명 한명 건너게 하며 디딤돌의 숫자를 줄여나간다면, 디딤돌의 값은 최대 2억이기 때문에 결코 시간안에 값을 구할 수 없을 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/algorithm-storage/static/0612ac1e7c5c1d1de8df8c44acf6a082/3a737/64062_graph.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.13513513513513%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABJ0lEQVR42qWS0XKCMBBF+///5Zu1VVEQihIsFIQEjITEhM12wI5Vh5k60/N4d+/uJnNf8B+8jKrW2mf0HzMAMMYuZQCwA9emqzJu1lpvw9ACIOLpdNp4Xj8IAK3FYRwi1nV9p1/NxpiIEESUUs6XS9fzhBD9zqEpjmPRtvnh8DqbjWw2Ukaui12X7HaB4xilNvMFSIVao9bTyWS/3Wb7z5QQludojD2fb8xCZMGHOBT+YmFFi1KmfhC8vRvOyySp0q/1dEpct2ua2PdRtLaVv2alVERI0zRZnl9+CBFpVTnu2lmt+gcfj5xzRPSDQCl1d7YFCMOQUco5p2XJKKVlyTkviiKKooqxY93DGEuTJM8yfXs2InZdBwN2jIfSY0ieDMbfCXsynt+wm7kS5S/BwAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"64062_graph\"\n        title=\"\"\n        src=\"/algorithm-storage/static/0612ac1e7c5c1d1de8df8c44acf6a082/fcda8/64062_graph.png\"\n        srcset=\"/algorithm-storage/static/0612ac1e7c5c1d1de8df8c44acf6a082/12f09/64062_graph.png 148w,\n/algorithm-storage/static/0612ac1e7c5c1d1de8df8c44acf6a082/e4a3f/64062_graph.png 295w,\n/algorithm-storage/static/0612ac1e7c5c1d1de8df8c44acf6a082/fcda8/64062_graph.png 590w,\n/algorithm-storage/static/0612ac1e7c5c1d1de8df8c44acf6a082/efc66/64062_graph.png 885w,\n/algorithm-storage/static/0612ac1e7c5c1d1de8df8c44acf6a082/3a737/64062_graph.png 897w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>고민을 하다 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">s</mi></mrow><annotation encoding=\"application/x-tex\">\\rm stones</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">stones</span></span></span></span></span></span> 의 값을 2차원 그래프로 그려보았더니 시간안에 해결할 수 있는 방법이 보였다.</p>\n<p>디딤돌에 적힌 숫자를 y축에 표현하였는데, y축의 값은 곧 <strong>건너갈 수 있는 니니즈 친구들의 숫자</strong>라고 생각해도 되는 것이었다.</p>\n<p>사진의 그어진 빨간 점선의 경우를 예로 들면, <em>\"3명의 니니즈 친구들이 징검다리를 건널 수 있는가?\"</em> 라는 <strong>질문</strong>을 던질 수 있고, 건너뛸 수 있는 디딤돌의 수 <code>k</code> 값에 따라 건널 수 있는지를 판단할 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th>건너뛸 수 있는 디딤돌의 수 (k)</th>\n<th>건널 수 있는가</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>2</td>\n<td>no</td>\n</tr>\n</tbody>\n</table>\n<p>3번째 니니즈 친구가 징검다리를 건널 때 연속된 2개의 디딤돌이 이미 0이 되었으므로 <code>k</code>가 2보다 큰 값이어야 건널수 있다.</p>\n<p>건널 수 있는 니니즈 친구들의 숫자를 최소 1에서 2억으로 잡고, 중간 값 <code>m</code>으로 <em>\"m명의 니니즈 친구들이 징검다리를 건널 수 있는가?\"</em> 라는 질문(a.k.a. 결정조건)을 던져가며 범위를 조절<sup><a id=\"rfn_1\" href=\"#fn_1\">[1]</a></sup>해나가는 <strong>파라메트릭 서치</strong>를 이용하면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">N</mi><mi>log</mi><mo>⁡</mo><mi mathvariant=\"normal\">N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\rm O(N \\log N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">O</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">N</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathrm\">N</span><span class=\"mclose\">)</span></span></span></span></span></span> 시간안에 정답을 구할 수 있다.</p>\n<h2>실수한 점</h2>\n<ol>\n<li>파라메트릭 서치의 결정조건의 알고리즘을 올바르게 작성하지 않았다.</li>\n</ol>\n<deckgo-highlight-code language=\"js\" theme=\"one-light\"  highlight-lines=\"2\">\n          <code slot=\"code\">const canGo = (c) =&gt; {\n  const newStones = stones.map((v) =&gt; (v - c &lt;= 0 ? 0 : 1)).join(&#39;&#39;);\n  const zeroStones = Array(Math.min(2e5, k)).fill(&#39;0&#39;).join(&#39;&#39;);\n\n  return (\n    newStones.indexOf(zeroStones) === -1\n  );\n};</code>\n        </deckgo-highlight-code>\n<p>결정 조건을 확인하는 함수 <code>canGo</code>는 <code>c</code>명이 건너갔을 때의 징검다리 상태를 확인하는 것이므로, 디딤돌의 숫자가 음수일 때 건너지 못하는 상태 <code>0</code>으로 판단해야 했는데, 0일 때 에도 건너지 못하는 상태라고 처리했었다. (0이라는 것은 숫자가 1인 디딤돌을 마지막으로 밟고 지나갔다는 것을 의미한다.)</p>\n<br/>\n<ol start=\"2\">\n<li>파라메트릭 서치의 결정조건의 알고리즘을 비효율적으로 작성하여 시간초과가 났다.</li>\n</ol>\n<deckgo-highlight-code language=\"js\" theme=\"one-light\"  highlight-lines=\"2,3\">\n          <code slot=\"code\">const canGo = (c) =&gt; {\n  const newStones = stones.map((v) =&gt; (v - c &lt; 0 ? 0 : 1)).join(&#39;&#39;);\n  const zeroStones = Array(Math.min(2e5, k)).fill(&#39;0&#39;).join(&#39;&#39;);\n\n  return (\n    newStones.indexOf(zeroStones) === -1\n  );\n};</code>\n        </deckgo-highlight-code>\n<p>건널 수 있는 디딤돌과 그렇지 않은 디딤돌을 판단할 때, 현재 니니즈 친구들의 인원수에 따라 새로운 배열로 만들어 사용하였는데, 크기가 20만인 배열을 매번 할당하는 과정만으로도 시간초과가 발생하였다.</p>\n<br/>\n<ol start=\"3\">\n<li>이분 탐색의 범위 조절과 종료 조건을 제대로 설정하지 않았다.</li>\n</ol>\n<p>이분탐색을 구현할 때 항상 헷갈리는 부분이다. lower/upper bound를 구현할 때에는 또 다르기 때문이다.</p>\n<p>나름 이유를 가지고 코드를 작성하였는데 앞으로 파라메트릭 서치를 구현할 땐 다음과 같이 작성하려고 한다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-light\"  highlight-lines=\"4 9 11\">\n          <code slot=\"code\">let l = 1;\nlet r = 2e8;\n\nwhile(l &lt;= r) {\n  const m = Math.floor((l + r) / 2);\n  \n  if(canGo(m)) {\n    answer = m;\n    l = m + 1;\n  } else {\n    r = m - 1;\n  }\n}</code>\n        </deckgo-highlight-code>\n<h2>각주</h2>\n<p><a id=\"fn_1\" href=\"#rfn_1\">[1]</a> 결정 조건 질문에 대한 답이 참이면 니니즈 친구들의 수를 늘리고, 거짓이면 니니즈 친구들의 숫자를 줄인다.</p>","frontmatter":{"title":"Lv.3 징검다리 건너기"}}},"pageContext":{"slug":"programmers/징검다리 건너기.js","slugNoExt":"programmers/징검다리 건너기","repoName":"algorithm-storage","userName":"jeong57281","profileUrl":"https://avatars.githubusercontent.com/u/136826333?v=4","utterances":"junghyunbak/junghyunbak.github.io","googleSiteVerification":"LwKjAts-rLkskyg9wgFh0L-OC3Y2Eo2T4SBrqPjxu8c"}},"staticQueryHashes":[],"slicesMap":{}}