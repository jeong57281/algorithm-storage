{"componentChunkName":"component---src-templates-post-tsx","path":"/post/programmers/인사고과.js","result":{"data":{"file":{"ext":".js","name":"인사고과","fields":{"content":"function solution(scores) {\n  var answer = 1;\n\n  const n = scores.length;\n\n  const isInsentive = Array(n).fill(true);\n\n  const aToBs = (() => {\n    const aToBs = new Map();\n\n    scores.forEach(([a, b], i) => {\n      if (!aToBs.has(a)) {\n        aToBs.set(a, []);\n      }\n\n      aToBs.get(a).push({ v: b, i });\n    });\n\n    return aToBs;\n  })();\n\n  let threshold = 0;\n\n  [...aToBs]\n    .sort((a, b) => b[0] - a[0])\n    .forEach(([a, bs]) => {\n      bs.forEach((b) => {\n        if (threshold > b.v) {\n          isInsentive[b.i] = false;\n        }\n      });\n\n      threshold = Math.max(threshold, ...bs.map((b) => b.v));\n    });\n\n  if (!isInsentive[0]) {\n    return -1;\n  }\n\n  const sums = scores\n    .map(([a, b], i) => ({ s: a + b, i }))\n    .filter(({ i }) => isInsentive[i])\n    .sort((a, b) => b.s - a.s);\n\n  let prev = Infinity;\n\n  for (let i = 0, j = 0; i < sums.length; i++) {\n    const cur = sums[i];\n\n    if (prev !== cur.s) {\n      j = i;\n    }\n\n    if (cur.i === 0) {\n      answer = j + 1;\n      break;\n    }\n\n    prev = cur.s;\n  }\n\n  return answer;\n}\n","stampObject":{"modified":1684213977,"created":1684213977}}},"markdownRemark":{"html":"<h2>틀린 이유</h2>\n<h3>1. 문제를 잘못 읽어서</h3>\n<p>인센티브를 받지 못하는 사원들은 비교 대상에서 제외해주어야 하는데, 완호가 인센티브를 받을 수 있는지에 대해서만 조사했기 때문에 틀렸다.</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\rm N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">N</span></span></span></span></span></span> 값이 최대 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>100</mn><mo separator=\"true\">,</mo><mn>000</mn></mrow><annotation encoding=\"application/x-tex\">100,000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">100</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">000</span></span></span></span></span> 으로 주어졌다는 것은 시간 복잡도를 계산해서 효율적으로 풀어야 하는 문제라는 것인데, 너무 쉽게 솔루션이 떠올랐다면 문제를 제대로 읽은게 맞는지 의심해 보았어야 했다.</p>\n<h3>2. 정렬을 하긴 했는데...</h3>\n<p>문제는 시간안에 <strong>모든 사원</strong>의 인센티브 수령 여부를 추려내는 알고리즘을 작성하는 것이 관건이다.</p>\n<p><code>근무태도</code>, <code>동료평가</code> 점수가 모두 높은 사원이 한명이라도 있는지를 판단해야 하기 때문에 점수별로 줄세우기를 해야 효율적으로 알고리즘을 작성할 수 있을 것이라 생각했고, <strong>정렬</strong>을 통한 풀이를 생각해보았다.</p>\n<p><code>근무태도</code>를 기준으로 정렬을 하긴 했지만, 현재 사원보다 앞에 있는 사원들(<code>근무태도</code>가 같거나 높은 사람들)의 <code>동료평가</code> 점수가 남아있었다.</p>\n<p>일일이 비교하는 방법은 복잡도가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">O</mi><mo stretchy=\"false\">(</mo><msup><mi mathvariant=\"normal\">N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\rm O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></span> 가 되어 시간안에 해결할 수 없었고, 다른 방법은 떠오르지 않아 결국 답을 보았다.</p>\n<h2>해결 방법</h2>\n<p>임계값(threshold)을 이용한 방법.</p>\n<blockquote>\n<p><code>근무태도</code>를 기준으로 내림차순 정렬이 되어 있는 상태에서 순차적으로 탐색하며, <code>동료평가</code>의 최대값을 갱신한다.</p>\n</blockquote>\n<p>현재 사원보다 <code>근무태도</code>가 높은 사람들의 모든 <code>동료평가</code>값이 필요한 것이 아니라, 최대 <code>동료평가</code>값만 알면 되기 때문이다.</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\rm O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">O</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">N</span><span class=\"mclose\">)</span></span></span></span></span></span> 안에 순차적으로 탐색하면서 인센티브를 수령여부를 판단할 수 있게 된다.</p>\n<p>최종 복잡도는 정렬 알고리즘을 사용하기 때문에 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">N</mi><mi>log</mi><mo>⁡</mo><mi mathvariant=\"normal\">N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\rm O(N \\log N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">O</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">N</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathrm\">N</span><span class=\"mclose\">)</span></span></span></span></span></span> 로 정복된다.</p>\n<h2>구현 방법</h2>\n<ol>\n<li><code>근무태도</code>를 내림차순으로 정렬하고, 같은 값에 대해서는 <code>동료평가</code>를 오름차순으로 정렬한다.</li>\n</ol>\n<p>동료평가를 오름차순으로 정렬한 이유는, 임계치를 갱신할 때 같은 <code>근무태도</code>의 높은 <code>동료평가</code>값이 먼저 갱신되면 올바르지 못한 값이 나오기 때문이다.</p>\n<ol start=\"2\">\n<li><code>근무태도</code>별 <code>동료평가</code>값들을 분류한 다음, <code>근무태도</code>값을 기준으로 내림차순 정렬한다.</li>\n</ol>\n<p>각 <code>근무태도</code>의 모든 <code>동료평가</code>값들의 인센티브 수령여부 확인이 끝나면 임계값을 갱신하는 방법으로, 구현은 좀 더 복잡하지만 직관적으로 이해가 잘 되는 것 같아서 해당 방법으로 풀이하였다.</p>","frontmatter":{"title":"Lv.3 인사고과"}}},"pageContext":{"slug":"programmers/인사고과.js","slugNoExt":"programmers/인사고과","repoName":"algorithm-storage","userName":"jeong57281","profileUrl":"https://avatars.githubusercontent.com/u/44913775?v=4","utterances":"jeong57281/jeong57281.github.io","googleSiteVerification":"LwKjAts-rLkskyg9wgFh0L-OC3Y2Eo2T4SBrqPjxu8c"}},"staticQueryHashes":[],"slicesMap":{}}