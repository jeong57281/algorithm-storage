---
title: 'Lv.2 후보키'
subtitle: ''
tag: ['programmers', '조합']
link: 'https://school.programmers.co.kr/learn/courses/30/lessons/42890'
---

## 틀렸던 이유

모든 속성의 조합을 구할 때, <u>현재 조합이 유일성을 만족할 경우, 현재 조합에서 파생되는 새로운 조합은 최소성을 만족시키지 않는다</u>고 생각했기 때문에 최소성 만족 여부는 검사해주지 않았다.

맞는 말이긴 하나, 유일성을 만족시키지 못하는 조합이 새로운 속성과 함께 사용되어 유일성을 만족시키게 되었을 때, 해당 조합이 항상 최소성을 보장하지는 않는다.

예를 들면,

|0|1|2|
|-|-|-|
|a|a|1|
|a|a|2|
|b|c|2|

위 예제에서 후보키는 $\{0,2\}$, $\{1,2\}$ 두 개이다.

1. $\{0\}$ :x:
2. $\{0,1\}$ :x:
3. $\{0,1,2\}$ :o:(:x:)
4. $\{0,2\}$ :o:
5. $\{1\}$ :x:
6. $\{1,2\}$ :o:
7. $\{2\}$ :x:

하지만 내 알고리즘은 $\{0,1,2\}$ 도 후보키로 처리하고 있었다.

2에서 3으로 넘어가면서 유일성을 만족하게 되었으나 최소성을 만족시키지 못해서 후보키가 될 수 없지만, 최소성 만족 여부를 검사하지 않으니 후보키 중 하나로 처리했던 것이다.

## 풀이 방법

1. 모든 조합을 구하는 재귀 알고리즘
2. 유일성 체크 알고리즘
3. 최소성 체크 알고리즘

세 가지만 확실하게 구현하면 된다.

내가 작성한 최소성 체크 알고리즘은 속성을 하나씩 지워보며 유일성을 만족하는지를 확인한다.

무척 직관적으로 구현했기 때문에 알아보기엔 쉽지만 효율이 매우 나빠 보인다.

로우, 컬럼 수가 늘어나면 사용할 수 없을 것 같다.
