---
title: 'Lv.3 인사고과'
subtitle: ''
tag: ['programmers', '정렬', '그리디']
link: 'https://school.programmers.co.kr/learn/courses/30/lessons/152995'
---

## 틀린 이유

### 1. 문제를 잘못 읽어서

인센티브를 받지 못하는 사원들은 비교 대상에서 제외해주어야 하는데, 완호가 인센티브를 받을 수 있는지에 대해서만 조사했기 때문에 틀렸다.

$\rm N$ 값이 최대 $100,000$ 으로 주어졌다는 것은 시간 복잡도를 계산해서 효율적으로 풀어야 하는 문제라는 것인데, 너무 쉽게 솔루션이 떠올랐다면 문제를 제대로 읽은게 맞는지 의심해 보았어야 했다.

### 2. 정렬을 하긴 했는데...

문제는 시간안에 **모든 사원**의 인센티브 수령 여부를 추려내는 알고리즘을 작성하는 것이 관건이다.

`근무태도`, `동료평가` 점수가 모두 높은 사원이 한명이라도 있는지를 판단해야 하기 때문에 점수별로 줄세우기를 해야 효율적으로 알고리즘을 작성할 수 있을 것이라 생각했고, **정렬**을 통한 풀이를 생각해보았다.

`근무태도`를 기준으로 정렬을 하긴 했지만, 현재 사원보다 앞에 있는 사원들(`근무태도`가 같거나 높은 사람들)의 `동료평가` 점수가 남아있었다.

일일이 비교하는 방법은 복잡도가 $\rm O(N^2)$ 가 되어 시간안에 해결할 수 없었고, 다른 방법은 떠오르지 않아 결국 답을 보았다.

## 해결 방법

임계값(threshold)을 이용한 방법.

> `근무태도`를 기준으로 내림차순 정렬이 되어 있는 상태에서 순차적으로 탐색하며, `동료평가`의 최대값을 갱신한다.

현재 사원보다 `근무태도`가 높은 사람들의 모든 `동료평가`값이 필요한 것이 아니라, 최대 `동료평가`값만 알면 되기 때문이다.

$\rm O(N)$ 안에 순차적으로 탐색하면서 인센티브를 수령여부를 판단할 수 있게 된다.

최종 복잡도는 정렬 알고리즘을 사용하기 때문에 $\rm O(N \log N)$ 로 정복된다.

## 구현 방법

1. `근무태도`를 내림차순으로 정렬하고, 같은 값에 대해서는 `동료평가`를 오름차순으로 정렬한다.

동료평가를 오름차순으로 정렬한 이유는, 임계치를 갱신할 때 같은 `근무태도`의 높은 `동료평가`값이 먼저 갱신되면 올바르지 못한 값이 나오기 때문이다.  

2. `근무태도`별 `동료평가`값들을 분류한 다음, `근무태도`값을 기준으로 내림차순 정렬한다.

각 `근무태도`의 모든 `동료평가`값들의 인센티브 수령여부 확인이 끝나면 임계값을 갱신하는 방법으로, 구현은 좀 더 복잡하지만 직관적으로 이해가 잘 되는 것 같아서 해당 방법으로 풀이하였다.
